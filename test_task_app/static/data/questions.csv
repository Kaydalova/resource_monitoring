topic_id;title;question;answer
1;ООП;Зачем в python используется ключевое слово self?;"Когда мы создаём новый экземпляр класса, мы по сути создаём новый self, то есть новый объект.
<br>Под капотом мы при этом не создаём копию всего кода класса целиком где-то там в памяти. У всех экземпляров одного класса он один на всех, иначе нам бы не хватило никакой памяти, да это и не нужно. Когда мы обращаемся к конкретному экземпляру, Python использует в качестве self конкретный экземпляр с именно его конкретными атрибутами.
<br>Проверим при помощи функции id(), что у нас в двух экземплярах одного и того же класса одинаковое, а что отличается.
<br>class SomeClass():
<br>def __init__(self):
<br>self.attr = 0
<br>
<br>def describe(self):
<br>print(f&apos;{id(self)=}, {id(self.attr)=}, {id(self.describe)=}&apos;)
<br>
<br>a = SomeClass()
<br>b = SomeClass()
<br>
<br>a.describe()
<br>b.describe()

<br>>>> id(self)=140381617994768, id(self.attr)=9793024, id(self.describe)=140381619250816
<br>>>> id(self)=140381618062816, id(self.attr)=9793024, id(self.describe)=140381619250816
<br># ^-экземпляры разные атрибут пока одинаков метод тоже одинаковый

<br>Помните ""квантовую физику"" с mutable и immutable? Атрибут ""attr"" у нас сейчас один и тот же, но ведь экземпляры-то разные!?
<br>А ну-ка, изменим у экземпляра под именем a его значение, и поглядим, что получится.

<br>a.attr = 1
<br>a.describe()
<br>b.describe()
<br>>>> id(self)=140381617994768, id(self.attr)=9793056, id(self.describe)=140381619250816
<br>>>> id(self)=140381618062816, id(self.attr)=9793024, id(self.describe)=140381619250816

<br>У &apos;a&apos; теперь атрибут attr является другим объектом, это <class &apos;int&apos;> по адресу 9793056.
<br>То есть, Python не копирует всё подряд при создании нового экземпляра. Он делает это только при необходимости.
<br>Не стоило бы мне говорить об id() как об адресе в памяти, лучше думать что это уникальный идентификатор.
<br>Хотите удивиться ещё больше? Меняем self.attr = 0 в нашем классе на  self.attr = 65535, запускаем заново...
<br>>>> id(self)=140422513277632, id(self.attr)=9793056, id(self.describe)=140422514534016
<br>>>> id(self)=140422513276000, id(self.attr)=140422515259344, id(self.describe)=140422514534016

<br>А это как это так, self.attr теперь, судя по адресам, у двух экземпляров оказались раскиданы практически по разным вселенным?

<br>А дело в том, что:
<br>Actually, in order to save time and memory costs, Python always pre-loads all the small integers in the range of [-5, 256]. When a new integer variable in this range is declared, Python just references the cached integer to it and won’t create any new object.
<br>Все целые числа от -5 до +256 уже заранее прокэшированы (по сути являются синглтонами, об этом в другой раз) и если ваша переменная попадает в этот диапазон, то Python даже ничего нового не создаёт. Образно говоря, он ""перевешивает"" брелок с надписью ""экземпляра-такого-то-attr"" на ""гвозик"" с подписью ""int=0""."
1;Задача;Как проверить, что один кортеж содержит все элементы другого кортежа?;"Этот вопрос, как и многие другие, не на выдумывание алгоритма перебора, а на знание и умение вовремя применить готовый метод. Не нужно ничего изобретать, не нужно танцевать вокруг элементов кортежа, пытаясь наиболее эффективно перебрать одно через другое.

Самый простой способ - использовать метод issubset:

small = (1,2,3)
big = (4, 5, 6, 7, 1, 2, 4, 4, 3)
set(small).issubset(set(big))

>>>True

Вот вам совет: как только вы замечаете, что заиграла музыка и вас вот-вот унесёт божественный танец - остановитесь и подумайте, вспомните, что ""батарейки в комплекте"". Просто нужно знать, где они лежат, достать и использовать по назначению.

p.s. Туда же:

all(x in big for x in small)

>>>True"
2;Определение;Что такое ORM, где она используется и можно ли без нее обойтись?;"«Объектно-реляционное отображение» и означает «технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования»… т.е. ORM — прослойка между базой данных и кодом который пишет программист, которая позволяет созданые в программе объекты складывать/получать в/из бд.

Плюсы использования ORM :
Упрощенный доступ к данным: ORM скрывает сложности работы с SQL и базами данных, предоставляя более простой и понятный интерфейс для работы с данными.
Переносимость кода: Использование ORM позволяет писать код, который не зависит от конкретной СУБД, что упрощает перенос приложения на другую базу данных.

Когда можно обойтись без ORM?
Если ваше приложение имеет простую структуру данных
В некоторых случаях, особенно когда требуется максимальная производительность или определенные возможности базы данных, напрямую писать SQL-запросы может быть предпочтительным вариантом."
2;Определение;Primary key, Foreign key;"Primary key (первичный ключ) - это уникальный идентификатор для каждой записи (строки) в таблице базы данных. Он служит для однозначной идентификации каждой записи в таблице. Обычно первичный ключ представляет собой числовое значение или уникальную комбинацию значений полей.

Foreign key (внешний ключ) - это поле в таблице, которое связывает ее с первичным ключом другой таблицы. Внешний ключ позволяет строить отношения между таблицами.

Пример: Предположим, у нас есть две таблицы: ""Пользователи"" и ""Заказы"". В таблице ""Пользователи"" первичным ключом может быть идентификатор пользователя (например, UserID), а в таблице ""Заказы"" внешним ключом может быть поле UserID, которое ссылается на первичный ключ (UserID) в таблице ""Пользователи"". Таким образом, каждый заказ в таблице ""Заказы"" связан с конкретным пользователем из таблицы ""Пользователи"" через внешний ключ."
3;Определение;В чем различия merge vs rebase vs cherry-pick?;"Merge (слияние) используется для объединения изменений из одной ветки в другую.
- При выполнении merge Git создает новый коммит, который объединяет изменения из двух разных веток, сохраняя историю каждой из них.
- Это хороший выбор, когда вы хотите сохранить историю всех внесенных изменений и обозначить явное место объединения веток.

Rebase (перебазирование) используется для перемещения текущей ветки на другое место, основанное на другой ветке.
- При выполнении rebase, Git берет изменения, которые были сделаны в текущей ветке после ее отхода от базовой ветки (обычно это основная ветка), и «перебазирует» эти изменения поверх последнего коммита базовой ветки.
- Это создает чистую, линейную историю коммитов без лишних слияний, но переписывает историю текущей ветки, что может привести к проблемам, если ветка была опубликована или используется другими разработчиками.


Cherry-pick (выборочное копирование) используется для применения конкретных коммитов из одной ветки в другую.
- При выполнении cherry-pick, вы выбираете определенные коммиты из одной ветки и копируете их в текущую ветку.
Это удобно, когда вы хотите включить только определенные изменения из одной ветки в другую, без объединения всей ветки."
4;Определение;В чем отличие 401 и 403 ошибки?;"401 Unauthorized (Неавторизован) и 403 Forbidden (Запрещено) являются HTTP статусами, указывающими на ошибку доступа к ресурсу. 

Ошибка 401 Unauthorized означает, что клиент не предоставил аутентификационных сведений для доступа к запрашиваемому ресурсу.

Ошибка 403 Forbidden указывает на то, что доступ к запрашиваемому ресурсу запрещен, и клиент не имеет права на его использование. Это может быть связано с ограничениями прав доступа, настройками безопасности или другими ограничениями, установленными на сервере. "
4;Определение;Отличия методов http;"HTTP (Hypertext Transfer Protocol) - это протокол, используемый для передачи данных между клиентом и сервером в сети. В HTTP существуют различные методы (или запросы), которые определяют тип операции, выполняемой на ресурсе сервера:

GET:
Используется для получения данных с сервера.
Метод безопасен, то есть не должен изменять состояние сервера или ресурсов.

POST:
Используется для отправки данных на сервер для обработки.
Метод не безопасен, поскольку может изменить состояние сервера или ресурсов (например, создание новой записи на сервере).

PUT:
Используется для обновления или замены существующего ресурса на сервере.
Метод идемпотентный, то есть повторные запросы с одинаковыми данными не изменят состояние сервера.

DELETE:
Используется для удаления ресурса на сервере.
Также является идемпотентным методом.

PATCH:
Используется для частичного обновления ресурса на сервере.
Также является идемпотентным методом.

Идемпотентные методы - это методы в протоколе HTTP, которые можно вызывать несколько раз, и результат будет одинаковым, как если бы метод был вызван только один раз.
Неидемпотентные методы в протоколе HTTP - это методы, которые могут изменять состояние сервера или ресурсов с каждым их вызовом. Повторный вызов неидемпотентного метода может привести к различным результатам или изменению состояния на сервере.

Например, методы POST, PATCH и несуществующий в стандартном наборе метод X не являются идемпотентными. Повторный вызов метода POST может привести к созданию дубликатов ресурсов, а повторный вызов метода PATCH может привести к различным изменениям состояния ресурса в зависимости от того, какие изменения были применены при каждом вызове."
5;Определение;Middleware;"Middleware в Django - это компонент, который обеспечивает обработку запросов и ответов, позволяет добавлять дополнительную функциональность и обрабатывать запросы и ответы до того, как они достигнут представления (view).

Middleware в Django выполняет следующие функции:

Обработка запросов: Middleware может выполнять действия перед обработкой запроса в представлении. Например, он может проверять авторизацию пользователя, проверять CSRF-токены, выполнять логирование запросов и другие операции, которые должны быть выполнены перед обработкой запроса приложением.

Обработка ответов: Middleware может также изменять или добавлять информацию в ответ, возвращаемый веб-приложением. Например, он может добавлять заголовки к ответу, устанавливать кэш или изменять содержимое ответа."
5;Определение;Migrations - что такое и как работает.;"Миграции в Django - это механизм, который обеспечивает автоматическое создание и обновление структуры базы данных в соответствии с определенными моделями (models) в Django приложении.

Миграции позволяют вам создавать, изменять и удалять таблицы, поля и связи между ними, сохраняя данные, уже содержащиеся в базе данных. При создании или изменении моделей Django генерирует миграционные файлы, которые описывают изменения, необходимые для синхронизации базы данных с определенными моделями. Каждый файл миграции содержит инструкции, такие как создание таблиц, добавление полей или изменение существующих полей."
6;Определение;Кратко расскажите об особенностях, преимуществах и недостатках Flask;"У этого фреймворка небольшой размер исходной кодовой базы, поэтому его называют микрофреймворком. По умолчанию он включает в себя только обработчик запросов и шаблонизатор, а простейшее приложение на Flask может состоять всего из нескольких строк. Разработчики этого фреймворка осознанно хотели сохранить ядро простым, но расширяемым.
С помощью Flask можно реализовать практически любую задачу: от простого одностраничного сайта до серьёзного проекта с авторизацией, аутентификацией и другими возможностями. Flask подходит для задач, которые подразумевают гибкость в выборе компонентов. Разработчик сам принимает решение, что ему пригодится в работе. 
У Flask нет встроенной ORM, но фреймворк совместим со сторонними проектами — SQLAlchemy, PonyORM, Tortoise ORM и другими. Наиболее популярный среди них — SQLAlchemy.
Во Flask есть интерактивная оболочка.Это по сути обычный интерпретатор Python, который запускается в режиме командной строки и сразу же после запуска импортирует экземпляр приложения Flask."
7;Определение;Кратко расскажите об особенностях, преимуществах и недостатках FastAPI.;"Особенности FastAPI:

Автоматическая генерация документации: FastAPI автоматически генерирует интерактивную документацию API на основе аннотаций типов и комментариев к коду, что значительно упрощает разработку и поддержку API.
Поддержка асинхронности: FastAPI поддерживает асинхронное программирование с использованием синтаксиса async/await. Это позволяет обрабатывать запросы параллельно и повышает эффективность при работе с внешними сервисами или базами данных.
Встроенная валидация и сериализация данных: FastAPI предоставляет интеграцию с пакетом Pydantic для автоматической валидации входных данных, сериализации и десериализации моделей данных, что снижает количество ошибок и упрощает обработку данных.

Не подходит для всех случаев: FastAPI может быть излишним для простых веб-приложений или микросервисов с низкой нагрузкой. 
Относительная новизна: FastAPI является относительно новым фреймворком, поэтому у него может быть меньше комьюнити, чем у Django."
8;Определение;Разница continuous deployment vs continuous delivery;CI (непрерывная интеграция) — это способ интеграции изменений кода в репозиторий по несколько раз в день. У CD есть два значения: непрерывная доставка автоматизирует интеграцию в то время, как непрерывное развертывание автоматически выпускает финальную сборку для конечных пользователей. Регулярное тестирование в рамках CI/CD уменьшает количество ошибок и дефектов кода
